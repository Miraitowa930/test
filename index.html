<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <script src="./vue.js"></script>

</head>


<body>
    <!-- <div id="app-1">
<span v-bind:title="message">
    鼠标悬停几秒钟查看此处动态绑定的提示信息！
</span>
</div>

<script>
var app1 = new Vue({
    el: '#app-1',
    data: {
        message: '页面加载于 ' + new Date().toLocaleString()
    }
})
</script> -->



    <!--    <div id="app-1" >
{{ msg }}
</div>
<div id="demo">
'好开心的一天'<br>
<span style="display: none;">innerText，textContent哪个会获取到</span>
<script>
    const a = 1;
</script>
<style>
a:{}
</style>
</div>
<script>
// demo.textContent = '段漂亮';
// console.log(demo.textContent);
// console.log(demo.innerText);
new Vue({
 el:'#app-1',
 data:{
     msg:['漂亮'],
     msg1:'今天天气很好'
 }
})
</script> -->



    <!-- /*v-html*/ -->
    <!-- <input type="text" class='input1'>
<button class='button1'>提交</button>
<div id='app'>
<div v-html='msg'></div>
</div>
<script>
const oInput = document.getElementsByClassName('input1')[0];
const oButton = document.getElementsByClassName('button1')[0];
let msg = 'null';
const vm = new Vue({
    el:'#app',
    data:{
        msg:"今天又是早起的一天"
    }
})
// oInput.oninput = function(){
//   msg = oInput.value;
// }
oButton.onclick = function(){
  vm.msg = oInput.value;
}
</script> -->




    <!-- 
v-if ;v-else-if;v-else
-->
    <!-- <div id="app">
 <div v-if="type === 'A'">Allie最漂亮啦</div>
 <div v-else-if = "type ==='B'">Allie今天看起来不怎么好</div>
 <div v-else>Allie是一个小黑妞啦</div>
</div>
<script>
 const vm  = new Vue({
    el:'#app',
    data:{
        // show:true,
        type:'c'
    }

 })
</script> -->


    <!-- v-show -->
    <!-- <div id="app">
 <div v-show="show">Allie最漂亮啦</div>

</div>
<script>
 const vm  = new Vue({
    el:'#app',
    data:{
        // show:true,
        show:false
    }

 })
</script>  -->



    <!-- v-bind -->
    <!-- <div id="app"> -->
    <!-- 绑定一个特性 -->
    <!-- <div  v-bind:[attr] = "type" b ="xx" c="ss"></div> -->
    <!-- 绑定多个特性  利用对象;  v-bind 后面没有参数，而且绑定一个对象，键值对为特性-->
    <!-- <div v-bind="{name:'xx', age:'18',height:'160cm'}"></div> -->
    <!-- 也可以采用字符串拼接方法 -->
    <!-- <img :src=" 'https://' + imgUrl " alt=""> -->
    <!-- <div :class="`${a} ${b}`"></div> -->



    <!-- 绑定class  style  有[],{}语法 -->
    <!-- 绑定class  对象语法 -->
    <!-- <div :class="{red:true}">dfsfv</div>
         <div :class="{red:isRed}">zvds</div>
         <div :class="{red:true, green:true}">jjsbajkf</div> 
         <div :class="{red:isRed, green:isGreen}"></div> -->
    <!-- 绑定class  数组语法： -->
    <!-- <div :class="['red','green']" class="red green">dfsg</div>
         <div :class="[red,green]"></div>
         <div :class="[isRed ? red : '',green]"></div> -->
    <!-- 如果要写多个三目运算符，为了解决冗余可以在数组语法中使用对象语法 -->
    <!-- <div :class="[{red: isRed,b:isB},green]"></div> -->
    <!-- v-bind绑定的class和自己加的class不冲突，两个都可以并存 -->
    <!-- <div :class="{red:isRed}" class="red"  ></div> -->



    <!-- 绑定style -->
    <!-- 对象语法 -->
    <!-- 1.直接在行间写 -->
    <!-- <div  :style="{color:'red',width:'10px',fontSize:'10px'}"> dhussjzb </div> -->
    <!-- 2.在data对象中写 -->
    <!-- <div :style = "styleObj"></div> -->
    <!-- 数组语法  可以绑定多个style -->
    <!-- <div :style="[styleObj1,styleObj2]">duanxiaofu</div> -->
    <!-- 绑定时会自动添加前缀 -->
    <!-- 多重值 ：  style 绑定中的属性提供一个包含多个值的数组，常用于提供多个带前缀的值: -->
    <!-- <div v-bind:style="{ display: ['-webkit-box', '-ms-flexbox', 'flex'] }"></div> -->
    <!-- 
            v-bind修饰符：
            .camel  将属性名驼峰化
            .prop  用于绑定DOM属性 
            .sync
          -->
    <!-- <svg :view-Box.camel="viewBox"></svg> -->
    <!-- <div :text-content.prop=" '小芙' "></div> -->
    <!--  循环DOM的属性
        
        <div id="demo"></div>
        <script>
            const demo=  document.getElementById("demo");
            for(let key in demo){
                console.log(key);
            }
        </script> -->

    <!-- </div>
     <script> 
         const vm  = new Vue({
            el:'#app',
            data:{ 
                type:"D",
                attr:"a",
                isRed:true,
               imgUrl:"t9.baidu.com/it/u=1307125826,3433407105&fm=79&app=86&size=h300&n=0&g=4n&f=jpeg?sec=1595317399&t=ccc2df18385e4ea50c2a27cb19c2a002",
               
                a:'isA',
                b:'isB',
                isB:true,
                isGreen:true,
                red:'redClass',
                green:'greenClass',
                styleObj1:{
                   color:'green',
                   backgroundColor:'pink',
                   fontSize:"10px",


                },
                styleObj2:{
                    cursor:'pointer'

                },
                viewBox:"0 0 100 100"


            }

         })
     </script>  -->



    <!-- v-on -->
    <!-- 监听Dom事件，用于行间 -->
    <!-- 原生实现 -->
    <!-- <div id="app">
      <button id="button1">点击</button>
      <p   id= "p1"></p>

   </div>
      <script> 
    const button = document.getElementById("button1");
    const p = document.getElementById("p1");
    var counter = 0;
    button.onclick = function myFunction(){
           counter += 1;
           const m = counter;
           p.innerHTML = "被点击了" + m + "次";    
    }; -->


    <!-- v-on实现 -->
    <!-- 在HTML中监听事件好处 -->
    <!-- 扫一眼 HTML 模板便能轻松定位在 JavaScript 代码里对应的方法。
        无须在 JavaScript 里手动绑定事件， ViewModel 代码是非常纯粹的逻辑，和 DOM 完全解耦，更易于测试
        当一个 ViewModel 被销毁时，所有的事件处理器都会自动被删除。无须担心如何清理它们 -->


    <!-- <div id="app"> -->
    <!-- 
            v-on指令 
        
          -->
    <!-- <button v-on:click="counter += 1">点击</button>
         <p>按钮被点击了{{ counter }} 次</p> -->
    <!-- 访问事件对象 , 使用$event -->
    <!-- <button v-on:click="addCounter(5,$event)">点击</button>
        <p>按钮被点击了{{ counter }} 次</p> -->
    <!-- 绑定动态事件 -->
    <!-- <button v-on:[event]="addCounter(5,$event)">点击</button>
         <p>按钮被点击了{{ counter }} 次</p> -->
    <!-- v-on="{}"   有限制:不能传参-->
    <!-- <button v-on="{click : addCounter}">点击</button>
         <p>按钮被点击了{{ counter }} 次</p> -->
    <!-- 缩写为@ -->
    <!-- <button @click="addCounter(5,$event)">点击</button>
           <p>按钮被点击了{{ counter }} 次</p> -->

    <!-- </div> 
        <script>
            const vm = new Vue({
                el: '#app',
                data: { 
                    counter: 0,
                    event:"click"
                    //this指向window
                },
                methods: {
                    addCounter(num,e) {
                        this.counter += 5;
                        console.log(e.target);
                    }
                }
            })
        </script> -->



    <!-- 
            
            v-on指令修饰符
        
        -->
    <!-- <div id="app"> -->
    <!-- 一、 事件修饰符 -->

    <!-- 1.阻止事件冒泡  .stop   -->
    <!-- <div @click="alert('div')" :style="{backgroundColor:'red'}">
                <button @click.stop="alert('button')">点击</button>
            </div> -->
    <!-- 2.阻止默认事件  .prevent-->
    <!-- <form  @submit.prevent="onSubmit">   
                <input type="submit">
            </form> -->
    <!-- 3.开启事件捕获模式   .capture -->
    <!-- <div @click.capture="alert('div')" :style="{backgroundColor:'red'}">
                <button @click="alert('button')">点击</button>
            </div> -->
    <!-- 4.只点击自身时才会触发事件 .self  -->
    <!-- <div @click.self="alert('div')" :style="{backgroundColor:'red'}">
            <button @click="alert('button')">点击</button>
        </div> -->
    <!-- 5.  只执行一次  .once-->
    <!-- <div @click.once="alert('div')" :style="{backgroundColor:'red'}">
            <button @click="alert('button')">点击</button>
        </div> -->
    <!-- 6.     .passive
               设置addEventListeners passive 选项 
               告诉浏览器阻不阻止默认事件，比如设置滚动，如果加上.prassive，
               就知道不需要阻止默认事件，页面会在触碰时立即滚动，如果不加，页面刚开始不会
               滑动，在所有函数执行完之后才知道不需要阻止默认事件，进行滑动。这就提高了移动端的性能
            -->
    <!-- 使用这些修饰符需要注意的点 -->
    <!-- 1.使用顺序，可以根据自己的需求进行调整。从左到右一次读。
             2.  .passive  和 .prevent 不能同时使用 
             -->

    <!-- 二、按键修饰符 -->
    <!-- 按键名 -->
    <!-- <input type="text" @keyup.enter="onSubmit"> -->
    <!-- 按键码 keyCode   回车是13   基本上已经被废弃了-->
    <!-- <input type="text" @keyup.13="onSubmit">  -->
    <!-- 按键码不好记忆 它的别名为 -->
    <!-- .enter 
             .tab 
             .delete 
             .esc 
             .space 
             .up  .arro- up
             .down 
             .left 
             .right  -->
    <!-- 配置按键码的别名 -->
    <!-- Vue.config.keyCodes.v = 86; -->
    <!-- Vue.config.keyCodes={
                 v:86,
                 f1:112
             } -->
    <!-- <input type="text" @keyup.v="onSubmit">  -->

    <!-- 三、系统按键修饰符 -->
    <!-- .ctrl 
             .alt 
             .shift 
             .meta  -->
    <!-- <div @click.alt="onSubmit">dxf</div> -->
    <!-- 我们试着按着alt  和 shift键 发现同样会触发事件，.exact修饰符
             规定的按键的精确性 -->

    <!-- .exact  2.5.0+以上使用 -->
    <!-- <div @click.alt.exact="onSubmit">dxf</div> -->
    <!-- 如果只加.exact修饰符，指按住任何的系统键不能触发，不按系统键则触发   -->
    <!-- <div @click.exact="onSubmit">dxf</div> -->

    <!-- 四、鼠标按钮修饰符 -->
    <!-- left
             right
             middle -->
    <!-- </div> -->
    <!-- <script>
        Vue.config.keyCodes.v = 86; 
        const vm = new Vue({
            el: "#app",
            methods: {
                alert(str) {
                    alert(str);
                },
                onSubmit() {
                    console.log('a');
                }
            }

        })

    </script> -->



    <!-- 列表渲染 -->
    <!-- 利用v-for指令，基于数据多次渲染元素 -->
    
      <!-- v-for指令  使用数组-->
      <!-- (item,index) in  arr  -->
      <!-- v-for 使用对象 -->
      <!-- (value,key,index) in obj -->
      <!-- in 可以用  of 代替 --> 
      <!-- v-for使用数字 -->
      <!-- num in number -->
      <!-- v-for使用字符串 -->
      <!-- str in string -->

    <div id="app">
        <ul>
            <!-- <li v-for="person in persons1">
                {{ person }}
            </li> -->
             <!-- v-for指令  使用数组-->
            <!-- <li v-for="(value,index) in persons2">
                {{ value }}--{{ index }}
            </li> -->
             <!-- v-for 使用对象 -->
            <!-- <li v-for="(value ,key,index) in duan">
                {{ value }}--{{ key }}--{{ index }}
            </li> -->
            <!-- v-for中使用数字 -->
            <!-- <li v-for="num in 10">{{ num }}</li> -->
            <!-- v-for使用字符串 -->
            <!-- <li v-for=" item in 'duanxiaofu' ">{{ item }}</li> -->
         
        <!-- 应用：比如我们要实现
         <li></li>
         <span></span>
         <li></li>
         <span></span> 
         这个样子的标签排列
        --> 
<!-- 
         <li v-for="person in persons2">{{ person.name }}</li>
         <span v-for="person in persons2">{{ person.age}}</span> -->
         <!-- 可以看到并不是要实现的效果，我们可以在外边加一个div，多次渲染在div上 -->
          <!-- <div v-for="person in persons2">
              <li>{{ person.name}}</li>
              <span>{{ person.age}}</span>
          </div> -->
          <!-- 效果实现了，但可以发现，遍历后每一个外边都创建了一个div，我们知道dom的操作当然越少越好
          我们可以使用 上一篇文章提到的 <template>标签,不可见元素，不会渲染到页面中的dom元素 -->
            <!-- <template v-for="person in persons2">
                <li>{{ person.name}}</li>
                <span>{{ person.age}}</span>
            </template>   -->

        <!-- vue的就地更新策略 -->
        <!-- 举个例子： -->
         <!-- <li v-for="(person,index) in persons2" @click="handleClick(index)">
              {{ person.name }}
            <input type="'text'">
            <input type="submit">
         </li> -->
         <!-- 根据结果可以发现，值复用了，虽然渲染起来没有那么麻烦，而大多时候，
         我们不需要这种情况，为了使内容，提交按钮全部移动，就需要加一个key值，且
         规定每个key值不能相同 -->
         <!-- key  必须是唯一的   要求为 string/number  不要写数组或对象类型 -->
         <!-- <li v-for="(person,index) in persons2"  :key="person.name">
            {{ person.name }}
          <input type="'text'">
          <input type="submit" @click="handleClick(index)" >
       </li> -->
       <!-- 使用key值应该注意的点 -->
       <!-- 一般不使用index作为key值，index虽然为唯一的，但是他在修改dom之后，会重新给index赋值
        当检测到重新赋值后的index内容和之前的不同时，它会把之前的会删掉重新渲染，这样消耗性能是非常大的
       -->
       <!-- 自己可以把key值作为index和name试一下，在控制台选中元素看一下效果 -->
       <!-- <input type="submit" @click="handleClick" >
       <li v-for="(person,index) in persons2"  :key="person.index">
        {{ person.name }}
        </li> -->


        <!-- v-for和v-if同时使用应该注意的点 -->
        <!-- 举例： -->
        <!-- <li  v-for="person in persons3"  v-if="person.isActive" >         
            {{ person.name}}
        </li> -->
        <!-- v-for的优先级要比v-if高，所以它其实是这样渲染的 -->
         <!-- [1,2,3].forEach((item,index) =>{
             console.log(item)
         }) -->
         <!-- 但这样会消耗性能会很大，把所有属性遍历一遍，取出true，我们可以这样解决 -->
          <!--1. 我们写一个空数组：activePerson:[],用来存放符合if条件渲染后符合条件的元素,
           v-for直接渲染数组里面元素就行，节省性能
        -->
          <!-- <li  v-for="person in activePersons"  v-if="person.isActive" >         
            {{ person.name}}
        </li> -->
        <!-- 2.也可以将v-if写到它的父级上去 -->

        
         
       
        </ul>

    </div>
    <script>
    const vm = new Vue({
        el: "#app",
            data: {
                // persons1:['段小芙','duan','段小敏'],
                persons2: [
                    { name: '段小芙', age: 18 },
                    { name: 'duan', age: 19 },
                    { name: '段小敏', age: 15 },
                ],
                duan:{
                    name:'小芙',
                    age:18,
                    height:'165cm'

                },
                persons3: [
                    { name: '段小芙', age: 18 ,isActive:true},
                    { name: 'duan', age: 19 ,isActive:false},
                    { name: '段小敏', age: 15,isActive:true },
                ],
                activePersons:[],

            },
            methods:{
                // handleClick(index){
                //     const deleteItems = this.persons2.splice(index,1);
                //     this.persons2.splice(index + 1,0,...deleteItems);
                // },
                  handleClick(){
                  this.persons2.reverse();
                },
            },
             
    })
    vm.activePersons = vm.persons3.filter(item => item.isActive);
          
    </script>


















</body>

</html>